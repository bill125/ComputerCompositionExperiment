# <center>THCO MIPS指令计算机 系统设计和实现</center>

<center> 林锦坤 杨国炜 朱佳豪小组 </center>

[TOC]

## 实验环境

硬件环境：THINKPAD教学计算机。

软件环境：FPGA开发工具软件Xilinx ISE 14.7，串口调试精灵。

## 完成情况

## 硬件设计
采用五段流水设计，实现了分支预测，不支持延迟槽。存储上使用了两块SRAM，分别用于存储数据和指令，外设上支持读取键盘输入和显示VGA。

### 数据通路图

![DataPath](../DataPath.svg)

#### 冲突的解决

1. 结构冲突

   对于寄存器的冲突，采用的方法是在下降沿写入，读则一直在读。

   对于IM和DM的冲突，IM和DM会向外发送一个读取总线数据的请求，马上就会收到一个回复（组合逻辑完成），表示是否争抢到总线的资源。如果没有争抢到，就会向StallClearController发送一个StallRequest，这样流水就会停止，等待下一个周期再继续争抢资源。

2. 数据冲突

   主要通过3个旁路解决，在ForwardUnit中处理。遇到必须停止流水的指令时，StallClearController会将 PC, IF_ID 停住，等待下一个流水周期。

   代码中有一种极端的数据冲突没有考虑：即下条指令的值被当前指令改写。此时应当也暂停流水。但是由于地址的划分，这种情况是不可能出现的，故没有考虑。

3. 控制冲突

   使用分支预测解决冲突。当预测出错时，会将读错的指令清空，具体是在下一个时钟周期给IF_ID清空，信号由StallClearController给出。

#### uart读写

#### sram读写

### 高分辨率VGA的实现
(例如计算最高刷新率、计算VGA显存量等)

### 硬件中断

实现了键盘中断和时钟中断。中断后PC会调到预先设置好的中断处理代码，处理完后再跳回原来的PC。具体如下：

中断到来，由BreakController向StallClearController发送中断使能和处理中断的PC，并存储流水第一或者第二阶段的PC，记为EPC，然后把流水前两个阶段的指令清空，并且置中断状态为1，表示不允许中断。中断处理完成后，使用一条特殊的指令，跳回到EPC，并把中断寄存器清0。

每次都把前两个阶段的指令清空，是由于跳转指令只会出现在前两个阶段，所以需要将其清空。跳回来的时候，正常是应当跳回第二阶段的PC，但是第二阶段的PC可能是分支预测出错清空的PC，所以这时候应当选择第一阶段的PC。

跳回的时候，不能马上将中断寄存器打开，否则如果跳回后马上中断，EPC记录的就是中断的最后一条指令了，这样会导致永远无法回到用户程序。所以需要等待至少一个流水周期后，才将中断开启。

跳回指令使用了一条不在我们要求的指令集里的指令SW_RS。这样只是为了方便，否则需要重写Assemblerer。

### 分支预测

存储了有8个表项的BTB，每个表项为2个寄存器，分别存储了跳转指令的地址(key)和应当跳去的地址(val)。每次读到一条指令就查表，如果找到相同的key，就以val作为下一个PC，否则就以PC+1作为下一个PC。

如果当前指令是跳转指令，就需要将此指令和跳转目标存入表中。如果找得到key相同的表项，更新即可，否则就将最早的表项替换掉。

使用25M时钟测试测例时，每个测例都能够有1s的速度提升。

## 软件设计

（forloop、增量更新、内存地址划分）

## 分工

林锦坤：主要负责流水中与控制冲突相关的部分，以及中断的处理。实现的元件为：PC, IF_ID, JumpAndBranch, ID_EX, EX_MEM, MEM_WB, StallClearController, BTB, BreakController, ClockBreak.

朱佳豪：主要负责SRAM，UART和VGA的读写，以及一部分实现部分软件功能。实现的元件为：IM, DM, ExtBusController, SystemBusController, UART, BusArbiter。

杨国炜：主要负责流水控制冲突外元件的编写，以及实现主要的软件功能。实现的元件为：myRegister, ImmExtend, Control, Decoder, ForwardUnit, ALU, ALU_MUX。

## 实用的工具与技巧

### 调试工具

1. Led灯输出阶段寄存器信息，以及重要的使能信号。
2. 采用click作为时钟，可以做到**单步调试**。
3. ISE内置一个**逻辑分析仪(ChipScope)**，能够设置采样时钟和要采样的信号，烧入板子后，设置采样的触发条件，触发成功后就可以在电脑上读出采得的数据。由于使用的是FPGA片内的资源，所以需要与工程一起编译。

### 时序优化

1. ISE的ip_core中提供了**DCM (digital clock management)**，其作用是精准的生成由输入时钟经过相移、分频等操作得到的时钟。我们可以利用此工具生成多种频率的时钟。当无法跑到50MHz，而可以跑25MHz的时候，可以生成25-50M之间的时钟，来测试最高主频。
2. ISE提供了**Timing Constraint**的功能，执行工具不会试图寻找达到最快速的布局&布线路径。——取而代之的是，执行工具会努力达到你所期望的性能要求。我们可以将所有的输出都加上Contraint，用于提高主频，但是编译时间可能会相应增长。
3. **删除**无用的**调试输出**，例如逻辑分析仪和led灯的输出。

### 其他
1. **重视warning**。Warning 会提示许多代码的漏洞。例如某个信号漏加到process敏感信号中，或者某个条件语句写错，导致某个信号无用，这些ISE都会报出Warning。此外对于ISE不推荐的写法，也会在Warning指出，例如写成process的组合逻辑的latch，三态门的使用等。
2. **消除latch。**若是将组合逻辑写成process，需要考虑到所有情况，并且在每种情况都将所有的信号的赋上值。真正需要latch的应该只有时序逻辑，时序逻辑中的Warning可以忽略。
3. **避免在fpga使用三态门**。三态门，即inout接口。FPGA内部是没有三态门，规范的编程应当只在管脚处使用三态门。若在内部也用三态门，ISE会自动帮我们转化为一系列组合逻辑。但这并不十分可靠，ISE也会报出Warning。最佳实践为避免使用三态门，尽量使用普通的组合逻辑。
4. **变量命名规范。**在我们的代码中，每个元件的接口信号都以`i_`, `o_`或`io_`开头，代表该信号是`in`, `out`还是`inout`类型，这样做优点是能够一眼看出每个信号的是否是接口，以及类型。
5. **自动生成CPUCore代码。**当用VHDL写完许多元件后，还需要将他们都在同一个元件中声明，并且把接口都接上。这是一个体力活，并且极其容易犯错（我们在这里就错了3处），难以查错。对于第一个步骤“将元件声明”，就是一个纯粹的体力活。我们为此写了自动生成代码的python脚本，位于`doc/gen_top.py`。对于接口，代码只会对每个输出的口建一个信号并接上，该信号明明规则为“元件名_接口名“。

## 遇到的困难和解决方法

1. **FA, F9无法成功烧入的解决办法。**这个问题很多组都有遇到。我们的解决方法是烧入后读出来进行比较，若有误重烧。
2. **栈帧寄存器的使用。**正常使用，应当先申请栈内存(ADDSP)，再使用栈(SW_SP)。但是结合上中断，这样就可能会产生漏洞：由于THINPAD寄存器数量有限，为了方便写软件应用，所有的寄存器都已用上，因而在中断处理中必须将寄存器暂存（压栈）后才能使用。如果软件应用没有预先申请栈内存，而是最后再ADDSP，中断后就可能改写栈内空间。
3. **PC+1 vs PC。**THINPAD指令集中关于PC的操作都是以下一条指令的指令地址作为PC，而我们最初设计时PC寄存器存的是当前指令的PC，导致流水出现了问题，花了不少时间才查出错。


## 实验心得